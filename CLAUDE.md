# Claude Code 設定 - 白熊堂プロジェクト

## 言語設定

- すべての出力は日本語で行ってください
- コミットメッセージ、コードコメント、説明文はすべて日本語で記述してください

## コードコメント

- コードコメントは日本語で記述してください
- 関数やクラスの説明は日本語で記述してください

## 基本的なルール

- **コードの品質**: 常にクリーンで、効率的、そして可読性の高いコードを生成してください
- **コードのリファクタリング**: 既存のコードをリファクタリングする際は、ロジックを機能単位で適切な関数に分割し、可読性と保守性を高めることを意識してください
- **import文**: 未使用のインポートは削除してください。既存のコードを扱う際は、使用中のimport文を勝手に変更・削除しないでください
- **ダミーのコード**: 動作しない、あるいは仮置きの関数や変数は含めないでください
- **コメント**: コードだけで意図が明確に伝わる場合、コメントは不要です。複雑なアルゴリズムや、特定のライブラリの少し特殊な使い方など、補足が必要な場合にのみ簡潔なコメントを記述してください
- **修正範囲**: ユーザーからの修正依頼があった部分以外は、原則として変更しないでください

## 設計原則

### 単一責任原則

機能を追加する場合は単一責任原則に基づいてコードを分割することを最優先とする

### YAGNI - 必要になるまで実装しない

- 現時点で必要な機能のみ実装すること
- 「将来使うかも」という理由で拡張機能を追加しないこと

### KISS - シンプルに保つ

- 最もシンプルな解決策を選ぶこと
- 複雑なパターンより単純な関数を優先すること

### DRY - 賢く適用

- 明確な重複パターンがある場合のみ共通化すること
- 2箇所なら重複を許容し、3箇所目で共通化を検討すること
- 似ているだけの異なるロジックを無理に共通化しないこと

## 型とコード品質

- **関数定義時には引数と返り値の型ヒントを必ず付けること**
- リントエラーを解消すること
- 修正を行う場合は可能な限り最小限の修正で済ませること
- **ハードコードとマジックナンバーを避けること**: 設定値や定数は `lib/config.ts` などで一元管理すること

## React / Next.js のベストプラクティス

> 参考: [Vercel React Best Practices](https://vercel.com/blog/introducing-react-best-practices)

パフォーマンスへの影響度順に優先度を設定:
- **CRITICAL**: 2-10倍の改善が見込める
- **HIGH**: 15-70%の改善
- **MEDIUM**: 意味のある改善
- **LOW**: 特定ケースでの最適化

---

### [CRITICAL] 非同期ウォーターフォールの排除

リクエストのウォーターフォールで600ms待たされる場合、`useMemo`の最適化は意味がない。

```tsx
// 悪い例: 不要なフェッチが先に実行される
async function handleRequest(userId: string, skipProcessing: boolean) {
  const userData = await fetchUserData(userId);
  if (skipProcessing) return { skipped: true };
  return processUserData(userData);
}

// 良い例: 必要な場合のみフェッチ
async function handleRequest(userId: string, skipProcessing: boolean) {
  if (skipProcessing) return { skipped: true };
  const userData = await fetchUserData(userId);
  return processUserData(userData);
}
```

- **独立した操作は`Promise.all()`で並列実行すること**
- **awaitは実際に値が必要になるまで遅延させること**
- **Suspense境界を戦略的に配置すること**: データ読み込み中もラッパーUIを表示

---

### [CRITICAL] バンドルサイズの最適化

300KBの余分なJavaScriptは、ループの最適化を無意味にする。

- **バレルファイルからのインポートを避けること**: 直接インポートで200-800ms削減

```tsx
// 悪い例: バレルファイル経由
import { Check } from "lucide-react";

// 良い例: 直接インポート
import Check from "lucide-react/dist/esm/icons/check";
```

- **重いコンポーネントは`next/dynamic`で動的インポートすること**
- **サードパーティライブラリはハイドレーション後に遅延読み込みすること**
- **ホバー/フォーカス時にプリロードして体感速度を向上させること**

---

### [HIGH] サーバーサイドパフォーマンス

- **Server Actionsでも認証を検証すること**: ミドルウェアだけでは不十分

```tsx
// 必須: Server Action内で認証確認
async function updateProfile(data: FormData) {
  "use server";
  await verifySession(); // 必ず検証
  // 処理続行
}
```

- **RSC境界でのシリアライズを最小化すること**: クライアントが使用するフィールドのみ渡す
- **`React.cache()`でリクエスト内の重複を排除すること**
- **`after()`でログやアナリティクスをノンブロッキングで実行すること**

---

### [MEDIUM-HIGH] クライアントサイドデータフェッチ

- **SWRで自動的にリクエストを重複排除すること**: 複数インスタンスで1リクエストを共有
- **パッシブイベントリスナーを使用すること**: `{ passive: true }`でスクロールパフォーマンス向上
- **localStorageはバージョン管理し、最小限のデータを保存すること**

---

### [MEDIUM] 再レンダリング最適化

- **派生状態はレンダリング中に計算すること**: state/effectではなく

```tsx
// 悪い例: 派生状態をuseStateで管理
const [fullName, setFullName] = useState("");
useEffect(() => {
  setFullName(`${firstName} ${lastName}`);
}, [firstName, lastName]);

// 良い例: レンダリング中に計算
const fullName = `${firstName} ${lastName}`;
```

- **単純な式を`useMemo`でラップしないこと**: オーバーヘッドが利益を上回る
- **関数型の`setState`を使用すること**: クロージャの古い値を防止

```tsx
// 良い例: 関数型更新
setItems((curr) => [...curr, ...newItems]);
```

- **遅延状態初期化を使用すること**: 高価な初期値は関数で渡す

```tsx
// 良い例: JSONパースを遅延
const [data] = useState(() => JSON.parse(stored));
```

- **頻繁に変わる非UI値は`useRef`に保存すること**
- **非緊急の更新は`startTransition()`でマークすること**

---

### [MEDIUM] レンダリングパフォーマンス

- **静的なJSX要素をコンポーネント外に抽出すること**: 再作成を防止
- **長いリストに`content-visibility: auto`を適用すること**: 画面外を遅延レンダリング
- **ハイドレーションミスマッチを防ぐ同期スクリプトを使用すること**
- **`suppressHydrationWarning`で既知の差異を抑制すること**
- **頻繁に切り替えるコンポーネントはActivityを使用すること**: state/DOMを保持
- **SVGはラッパー要素をアニメーションすること**: GPUアクセラレーションを有効化
- **明示的な条件レンダリングを使用すること**: falsyな値（`0`など）のレンダリングを防止

```tsx
// 悪い例: 0がレンダリングされる
{count && <Component />}

// 良い例: 明示的な条件
{count > 0 && <Component />}
```

---

### [LOW-MEDIUM] JavaScriptパフォーマンス

- **レイアウトスラッシングを避けること**: スタイル書き込みをバッチ処理してから読み取り
- **繰り返しルックアップにはインデックスMapを構築すること**: O(1)アクセス
- **複数の配列イテレーションを1つに統合すること**

```tsx
// 悪い例: 2回のイテレーション
const filtered = items.filter((x) => x.active);
const mapped = filtered.map((x) => x.name);

// 良い例: 1回のイテレーション
const result = items.reduce<string[]>((acc, x) => {
  if (x.active) acc.push(x.name);
  return acc;
}, []);
```

- **配列比較前に長さをチェックすること**: 早期リターン
- **`array.includes()`の代わりに`Set.has()`を使用すること**: O(1)ルックアップ
- **`sort()`の代わりに`toSorted()`を使用すること**: イミュータブルなソート
- **結果が決まったら早期リターンすること**: 不要な処理を回避
- **RegExpはレンダリング外で作成すること**: 毎回の再作成を防止
- **ループ内のMin/MaxはO(n)のループで求めること**: O(n log n)のソートを避ける

---

### [LOW] 高度なパターン

- **アプリ全体の初期化は一度だけ実行すること**: `useEffect([], ...)`ではなくモジュールレベルのガードを使用
- **イベントハンドラをrefsに保存すること**: 安定したサブスクリプションのため
- **`useEffectEvent`で最新値にアクセスすること**: 依存配列の再実行を回避

---

### Server Components と Client Components

- **デフォルトで Server Components を使用すること**: インタラクティブな機能が必要な場合のみ `"use client"` を追加
- **データフェッチは Server Components で行うこと**
- **Client Components は必要最小限にすること**: 状態管理やイベントハンドリングが必要な場合のみ使用

### コンポーネント設計

- **単一責任の原則**: 各コンポーネントは1つの責務を持つこと
- **状態のリフトアップ**: 共有状態は親コンポーネントで管理し、propsで子コンポーネントに渡すこと
- **型安全性**: コンポーネントのpropsには必ず型を付けること

### Hooks の使用

- **useState**: コンポーネント内のローカル状態管理に使用
- **useEffect**: 副作用の処理に使用。クリーンアップ処理を忘れないこと
- **useCallback**: propsとして子コンポーネントに渡す関数に使用
- **useMemo**: フィルタリング、ソート、グループ化などの重い計算処理に使用（ただし単純な式には不要）
- **カスタムフック**: `use`で始める命名規則（例: `useProductForm`, `useTabState`）

### イベントハンドリング

- **イベントハンドラーの命名**: `handle`で始めること（例: `handleClick`, `handleSubmit`）
- **非同期処理**: エラーハンドリングを必ず実装すること
- **副作用はイベントハンドラーで実行すること**: effect + stateではなく

### アクセシビリティ

- **aria-label**: アイコンや装飾的な要素には`aria-label`を設定すること
- **セマンティックHTML**: 適切なHTML要素を使用すること

## Tailwind CSS のベストプラクティス（v4）

### 基本方針

- **ユーティリティクラスを直接使用すること**: Tailwind の標準クラスをそのまま使用する
- **`@apply` は使用しないこと**: v4 では非推奨。代わりにラッパーコンポーネントを使用する
- **動的クラス名を避けること**: `bg-${color}-500` のような動的生成は使用しない（ビルド時に検出できない）

### テーマカスタマイズ

- **`@theme` ディレクティブを使用すること**: `globals.css` の `@theme inline` ブロックでテーマ変数を定義
- **CSS変数を活用すること**: テーマ全体で統一したい色やスペーシングは CSS 変数として定義

### スタイルの再利用

- **2-3箇所程度**: 明示的なクラス指定をそのまま使用
- **複雑なスタイル**: ラッパーコンポーネントを作成（例: `card-product.tsx`）
- **テーマレベル**: `@theme` 変数で定義

### レスポンシブデザイン

- **モバイルファースト**: デフォルトはモバイル、`sm:`, `md:`, `lg:` で拡張
- **一貫したブレークポイント**: プロジェクト全体で同じブレークポイントを使用

## shadcn/ui のベストプラクティス

### 基本方針

- **コンポーネントをそのまま使用すること**: shadcn/ui のコンポーネントは `app/components/ui/` に配置
- **カスタマイズは最小限に**: 必要な場合のみラッパーコンポーネントを作成

### ラッパーコンポーネント

- **命名規則**: 用途を明確にする（例: `card-product.tsx`, `badge-price.tsx`）
- **`cn()` ユーティリティを使用すること**: クラス名の結合には `cn()` を使用
- **props を透過的に渡すこと**: `...props` でベースコンポーネントに props を渡す

```tsx
// 良い例
export function ProductCard({ className, ...props }: ProductCardProps) {
  return <Card className={cn("カスタムクラス", className)} {...props} />;
}
```

### 既存のラッパーコンポーネント

- `card-product.tsx`: 商品タイル用
- `card-modal.tsx`: モーダル内のカード用
- `card-faq.tsx`: FAQ カード用
- `badge-price.tsx`: 価格表示用
- `badge-question.tsx`: 質問バッジ用

## 品質チェックリスト

実装前に以下を確認すること：

### 設計原則
- [ ] この機能は**今**必要か？（YAGNI）
- [ ] もっとシンプルな方法はないか？（KISS）
- [ ] 同じロジックが複数箇所に存在しないか？（DRY）
- [ ] 設定値や定数は一元管理されているか？

### パフォーマンス（CRITICAL）
- [ ] 非同期ウォーターフォールが発生していないか？
- [ ] 独立した非同期処理は`Promise.all()`で並列化しているか？
- [ ] バレルファイルからの大量インポートを避けているか？
- [ ] 重いコンポーネントは動的インポートしているか？

### パフォーマンス（その他）
- [ ] Server Actionsで認証を検証しているか？
- [ ] 派生状態をstate/effectで管理していないか？
- [ ] 単純な式を不必要に`useMemo`でラップしていないか？
- [ ] RSC境界で必要なフィールドのみを渡しているか？
- [ ] falsyな値の条件レンダリングは明示的か？（`count > 0 &&`）
